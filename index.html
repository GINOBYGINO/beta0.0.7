<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Bingo Rouge - Beta 0.0.7</title>
    <style>
        body, html { 
            margin: 0; padding: 0; overflow: hidden; 
            background: #050505; color: #e0e0e0; 
            font-family: 'Segoe UI', Courier, monospace; 
            user-select: none;
        }

        #game-layout { display: flex; align-items: center; justify-content: center; height: 100vh; gap: 40px; }

        /* --- 標題畫面 --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 200;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .title-text { font-size: 64px; font-weight: bold; color: #fff; letter-spacing: 4px; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .version-text { font-size: 24px; color: #73d13d; margin-bottom: 50px; }
        .start-btn {
            padding: 15px 50px; font-size: 24px; border: 2px solid #fff;
            background: transparent; color: #fff; cursor: pointer;
            transition: 0.2s; font-family: inherit;
        }
        .start-btn:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }

        /* 左側：升級紀錄 */
        #left-sidebar {
            width: 240px; height: 600px; 
            display: flex; flex-direction: column;
            border-right: 1px solid #333; padding-right: 20px;
        }
        #upgrade-history {
            flex: 1; overflow-y: auto; padding: 10px; 
            background: rgba(20,20,20,0.4); border-radius: 8px;
        }
        .history-item { 
            border-bottom: 1px solid #444; padding: 10px 0; 
            display: flex; flex-direction: column; gap: 4px;
        }
        .h-top { display: flex; justify-content: space-between; color: #73d13d; font-weight: bold; }
        .h-desc { font-size: 12px; color: #888; line-height: 1.4; }

        /* 中間：核心戰鬥區 */
        #main-area { display: flex; flex-direction: column; align-items: center; position: relative; }
        
        .enemy-box { 
            margin-bottom: 25px; text-align: center; 
            border: 1px solid #555; background: #111;
            padding: 15px; width: 380px; box-shadow: 0 0 15px rgba(0,0,0,0.5);
            border-radius: 8px; transition: border-color 0.2s;
        }
        .hp-bar-bg { width: 100%; height: 10px; background: #333; margin-top: 8px; border-radius: 5px; overflow: hidden; }
        #hp-bar-fill { width: 100%; height: 100%; background: #ff4d4f; transition: width 0.3s; }

        .grid {
            display: grid; grid-template-columns: repeat(6, 65px);
            grid-template-rows: repeat(6, 65px); gap: 8px;
            padding: 15px; background: #080808; border: 2px solid #444;
            border-radius: 12px;
        }
        .cell {
            width: 65px; height: 65px; background: #1a1a1a; border: 2px solid #333;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px; font-weight: bold; position: relative; border-radius: 6px;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden; /* 為了遮罩動畫 */
        }

        /* 升級閃光遮罩 (需求 3) */
        .cell::before {
            content: ""; position: absolute; top:0; left:0; width:100%; height:100%;
            background: #ffffff; opacity: 0; pointer-events: none; z-index: 20;
            transition: opacity 0.5s ease-in-out;
        }
        .cell.flash-white::before { opacity: 1; }
        
        /* 運算符顏色 */
        .op-plus { color: #40a9ff; } 
        .op-minus { color: #73d13d; } 
        .op-mult { color: #ff4d4f; } 
        .op-div { color: #ffec3d; } 
        .op-pow { color: #d3adf7; text-shadow: 0 0 5px #be82ff; }

        /* 狀態樣式 */
        .cell.marked { background: #222; }
        .cell.marked::after {
            content: ""; position: absolute; width: 45px; height: 45px;
            border: 4px solid #e03131; border-radius: 50%; box-shadow: 0 0 8px #e03131;
            z-index: 5;
        }

        /* 選項框改為白色 (需求 4) */
        .cell.option-candidate {
            border: 2px solid #ffffff; 
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        .cell.option-selected {
            border-color: #73d13d; /* 選中時變綠 */
            box-shadow: 0 0 20px #73d13d, inset 0 0 10px #73d13d;
            transform: scale(1.1);
            z-index: 10;
            background: #111;
        }

        /* 右側：數值面板 */
        #right-panel { width: 220px; padding-left: 30px; border-left: 2px dashed #333; height: 600px; display: flex; flex-direction: column; justify-content: center;}
        .val-num { font-size: 48px; margin-bottom: 20px; font-weight: bold; transition: color 0.2s; }
        #calc-step { color: #73d13d; height: 40px; font-size: 20px; margin-top: 10px; font-weight: bold; }

        .vibrate { animation: shake 0.1s infinite; color: #ff4d4f !important; }
        @keyframes shake {
            0% { transform: translate(2px, 2px); }
            50% { transform: translate(-2px, -2px); }
            100% { transform: translate(2px, -2px); }
        }

        /* 升級覆蓋層 */
        #upgrade-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: none; z-index: 100;
            flex-direction: column; align-items: center; justify-content: center;
        }
        .cards-container { display: flex; gap: 30px; }
        .card {
            width: 220px; height: 320px; background: #1a1a1a; border: 2px solid #444;
            border-radius: 12px; padding: 20px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; text-align: center;
            transition: 0.3s; position: relative;
        }
        .card:hover { border-color: #ffec3d; transform: translateY(-10px); background: #252525; }
        .card-name { font-size: 24px; margin-top: 40px; margin-bottom: 20px; color: #fff; }
        .card-desc { font-size: 14px; color: #aaa; line-height: 1.6; }

    </style>
</head>
<body>

<div id="start-screen">
    <div class="title-text">BINGO ROUGE</div>
    <div class="version-text">beta 0.0.7</div>
    <button class="start-btn" onclick="startGame()">START GAME</button>
</div>

<div id="upgrade-overlay">
    <div style="font-size:32px; color:#ffec3d; margin-bottom:40px;">LEVEL UP! 選擇升級</div>
    <div class="cards-container" id="cards-container"></div>
</div>

<div id="game-layout">
    <div id="left-sidebar">
        <div style="padding:10px; font-weight:bold; color:#fff; border-bottom:1px solid #444; font-size:18px;">獲得升級</div>
        <div id="upgrade-history"></div>
    </div>

    <div id="main-area">
        <div class="enemy-box">
            <div id="level-text" style="color:#aaa; letter-spacing:2px; font-size:14px;">FLOOR 1</div>
            <div style="font-size:24px; margin:5px 0;">ENEMY HP</div>
            <h2 id="enemy-hp-text" style="margin:0; color:#ff4d4f;">100 / 100</h2>
            <div class="hp-bar-bg"><div id="hp-bar-fill"></div></div>
        </div>

        <div class="grid" id="bingo-grid"></div>

        <div style="margin-top:20px; color:#555; font-size:14px;">← → 選擇 / 空白鍵 確認</div>
    </div>

    <div id="right-panel">
        <div style="color:#888; font-size:14px;">剩餘次數 (Turns)</div>
        <div id="turns-val" class="val-num" style="color:#ffec3d;">30</div>

        <div style="color:#888; font-size:14px;">基礎攻擊 (ATK)</div>
        <div id="base-atk-val" class="val-num" style="font-size:32px;">10</div>

        <div style="color:#888; font-size:14px;">當前傷害計算</div>
        <div id="current-calc-val" class="val-num" style="font-size:56px; color:#fff;">-</div>
        
        <div id="calc-step"></div>
    </div>
</div>

<script>
    // --- 遊戲狀態 ---
    let currentLevel = 1;
    let enemyMaxHp = 50;
    let enemyHp = 50;
    let baseAtk = 10;
    let remainingTurns = 30; // 初始 30
    
    let gridData = [];      
    let markedData = [];    
    let activeOptions = []; // 兩個選項的 index
    let selectionIdx = 0;   
    let isProcessing = false;
    
    let upgrades = [];
    let b2_counter = 0; 

    const opConfig = {
        '+': { class: 'op-plus', weight: 0 }, 
        '-': { class: 'op-minus', weight: 0 },
        '*': { class: 'op-mult', weight: 1 },
        '/': { class: 'op-div', weight: 1 },
        '^': { class: 'op-pow', weight: 2 }
    };

    function startGame() {
        document.getElementById('start-screen').style.display = 'none';
        initGame();
    }

    function initGame() {
        generateBalancedGrid();
        markedData = Array(36).fill(false);
        pickNewOptions();
        updateUI();
    }

    function generateBalancedGrid() {
        let isValid = false;
        let attempt = 0;
        
        while (!isValid && attempt < 1000) {
            let pool = [];
            // 平衡配置
            for(let i=0; i<10; i++) pool.push({op:'+', val: [2,4,6,8][rn(4)]});
            for(let i=0; i<8; i++)  pool.push({op:'*', val: [1.5,2,2.5,3][rn(4)]});
            for(let i=0; i<5; i++)  pool.push({op:'/', val: 2});
            for(let i=0; i<5; i++)  pool.push({op:'-', val: [1,2,3,4][rn(4)]});
            
            for(let i=0; i<8; i++) {
                let r = Math.random();
                if(r < 0.25) pool.push({op:'+', val: 4});
                else if(r < 0.5) pool.push({op:'*', val: 2});
                else if(r < 0.75) pool.push({op:'/', val: 2});
                else pool.push({op:'-', val: 2});
            }
            pool.sort(() => Math.random() - 0.5);
            
            let pass = true;
            for(let r=0; r<6; r++) {
                let rowOps = pool.slice(r*6, (r+1)*6);
                let mults = rowOps.filter(x=>x.op==='*').length;
                let divs = rowOps.filter(x=>x.op==='/').length;
                if (mults === 0 || mults > 3 || divs > 2) pass = false;
            }
            if(pass) {
                for(let c=0; c<6; c++) {
                    let colOps = [];
                    for(let r=0; r<6; r++) colOps.push(pool[r*6+c]);
                    let mults = colOps.filter(x=>x.op==='*').length;
                    let divs = colOps.filter(x=>x.op==='/').length;
                    if (mults === 0 || mults > 3 || divs > 2) pass = false;
                }
            }

            if(pass) {
                gridData = pool.map(p => ({...p, class: opConfig[p.op].class}));
                isValid = true;
            }
            attempt++;
        }
    }

    function rn(max) { return Math.floor(Math.random() * max); }

    function renderGrid() {
        const el = document.getElementById('bingo-grid');
        // 不清除 innerHTML，而是檢查是否需要更新或建立 (為了保留動畫 DOM)
        // 這裡為了簡化邏輯，若沒有動畫在跑，則重繪。若有動畫，透過動畫函式操作 DOM
        if (el.children.length === 0) {
            gridData.forEach((d, i) => {
                const cell = document.createElement('div');
                cell.className = `cell ${d.class}`;
                cell.id = `cell-${i}`;
                cell.innerText = `${d.op}${d.val}`;
                el.appendChild(cell);
            });
        } else {
            // 更新狀態
            gridData.forEach((d, i) => {
                const cell = document.getElementById(`cell-${i}`);
                if (!cell) return;
                
                // 保留動畫 class (flash-white)，重置其他
                const isFlashing = cell.classList.contains('flash-white');
                cell.className = `cell ${d.class} ${isFlashing ? 'flash-white' : ''}`;
                
                if (markedData[i]) cell.classList.add('marked');
                
                // 選項 UI
                if (!isProcessing && !document.getElementById('upgrade-overlay').style.display.includes('flex')) {
                    if (activeOptions.includes(i)) cell.classList.add('option-candidate');
                    if (activeOptions[selectionIdx] === i) cell.classList.add('option-selected');
                }
                
                // 文字只在非動畫遮蔽時更新，或動畫函式會強制處理
                if (!isFlashing) cell.innerText = `${d.op}${d.val}`;
            });
        }
    }

    function updateUI() {
        document.getElementById('enemy-hp-text').innerText = `${Math.floor(enemyHp)} / ${enemyMaxHp}`;
        document.getElementById('hp-bar-fill').style.width = `${Math.max(0, (enemyHp/enemyMaxHp)*100)}%`;
        document.getElementById('turns-val').innerText = remainingTurns;
        document.getElementById('base-atk-val').innerText = Math.floor(baseAtk);
        document.getElementById('level-text').innerText = `FLOOR ${currentLevel}`;
        renderGrid();
    }

    // --- 選項邏輯 (需求 1: 改為兩個) ---
    function pickNewOptions() {
        let unmarked = markedData.map((m, i) => m ? -1 : i).filter(i => i !== -1);
        if(unmarked.length === 0) { activeOptions = []; return; }

        activeOptions = [];
        let count = Math.min(2, unmarked.length); // 需求 1
        while(activeOptions.length < count) {
            let r = unmarked[rn(unmarked.length)];
            if(!activeOptions.includes(r)) activeOptions.push(r);
        }
        activeOptions.sort((a,b) => a - b);
        selectionIdx = 0; 
    }

    window.addEventListener('keydown', (e) => {
        if (isProcessing || remainingTurns <= 0 || document.getElementById('upgrade-overlay').style.display === 'flex' || document.getElementById('start-screen').style.display !== 'none') return;
        
        if (e.key === 'ArrowLeft') {
            selectionIdx = (selectionIdx - 1 + activeOptions.length) % activeOptions.length;
            updateUI();
        } else if (e.key === 'ArrowRight') {
            selectionIdx = (selectionIdx + 1) % activeOptions.length;
            updateUI();
        } else if (e.key === ' ') {
            e.preventDefault();
            confirmSelection();
        }
    });

    async function confirmSelection() {
        const targetIdx = activeOptions[selectionIdx];
        if (targetIdx === undefined) return;

        remainingTurns--;
        markedData[targetIdx] = true;

        if (hasUpgrade('B2')) {
            b2_counter++;
            if (b2_counter >= 3) {
                let unmarked = markedData.map((m, i) => m ? -1 : i).filter(i => i !== -1);
                if (unmarked.length > 0) markedData[unmarked[rn(unmarked.length)]] = true;
                b2_counter = 0;
            }
        }

        renderGrid();
        
        const lines = checkBingo();
        if (lines.length > 0) {
            isProcessing = true;
            activeOptions = []; 
            renderGrid();
            await processDamage(lines);
            isProcessing = false;
        }

        updateUI();

        if (enemyHp <= 0) {
            setTimeout(showUpgradeUI, 600);
        } else if (remainingTurns <= 0) {
            alert("次數耗盡，遊戲結束。");
            location.reload();
        } else {
            pickNewOptions();
            updateUI();
        }
    }

    function checkBingo() {
        let lines = [];
        const reqCount = hasUpgrade('B3') ? 5 : 6;
        const checkLine = (indices) => {
            if (indices.filter(i => markedData[i]).length >= reqCount) lines.push(indices);
        };
        for(let r=0; r<6; r++) checkLine([0,1,2,3,4,5].map(c => r*6+c));
        for(let c=0; c<6; c++) checkLine([0,1,2,3,4,5].map(r => r*6+c));
        checkLine([0,7,14,21,28,35]);
        checkLine([5,10,15,20,25,30]);
        return lines;
    }

    async function processDamage(lines) {
        let currentAtk = baseAtk * lines.length;
        
        // 需求 2: 初始不補次數，除非有 D3 升級
        let turnsGained = 2;
        if (hasUpgrade('D3')) turnsGained += 3 * lines.length;
        remainingTurns += turnsGained;

        const numDiv = document.getElementById('current-calc-val');
        const stepDiv = document.getElementById('calc-step');
        
        numDiv.innerText = Math.floor(currentAtk);
        stepDiv.innerText = `連線數 ${lines.length} x 基礎攻擊` + (turnsGained > 0 ? ` (+${turnsGained} Turns)` : "");
        await new Promise(r => setTimeout(r, 600));

        let uniqueIndices = [...new Set(lines.flat())];
        let cells = uniqueIndices.map(i => ({...gridData[i], index: i}));
        cells.sort((a, b) => opConfig[a.op].weight - opConfig[b.op].weight);

        for (let cell of cells) {
            let prev = currentAtk;
            if (cell.op === '+') currentAtk += cell.val;
            else if (cell.op === '-') currentAtk -= cell.val;
            else if (cell.op === '*') currentAtk *= cell.val;
            else if (cell.op === '/') currentAtk /= cell.val;
            else if (cell.op === '^') currentAtk = Math.pow(currentAtk, 2);

            markedData[cell.index] = false; 
            const cellDom = document.getElementById(`cell-${cell.index}`);
            if(cellDom) cellDom.classList.remove('marked'); 

            stepDiv.innerText = `${Math.floor(prev)} ${cell.op} ${cell.val}`;
            numDiv.classList.add('vibrate');
            numDiv.innerText = Math.floor(currentAtk);

            await new Promise(r => setTimeout(r, 500));
            numDiv.classList.remove('vibrate');
        }

        if (hasUpgrade('C2')) {
            baseAtk += 2;
            stepDiv.innerText = "被動: 基礎攻擊+2";
            await new Promise(r => setTimeout(r, 500));
        }

        stepDiv.innerText = `造成 ${Math.floor(currentAtk)} 傷害`;
        enemyHp = Math.max(0, enemyHp - Math.floor(currentAtk));
        
        document.querySelector('.enemy-box').style.borderColor = 'red';
        updateUI();
        await new Promise(r => setTimeout(r, 200));
        document.querySelector('.enemy-box').style.borderColor = '#555';
        
        await new Promise(r => setTimeout(r, 800));
        stepDiv.innerText = "";
        numDiv.innerText = "-";
    }

    // --- 升級系統 ---
    const upgradeDefs = [
        { id: 'A1', lv: 1, w: 9, name: '亂流重組', desc: '隨機重置棋盤上的 5 個格子' },
        { id: 'C1', lv: 1, w: 9, name: '力量增幅', desc: '基礎攻擊力 +3' },
        { id: 'D1', lv: 1, w: 4, name: '時光沙漏 I', desc: '每回合起始剩餘次數 +3' }, // 新 D1
        { id: 'E1', lv: 1, w: 6, name: '點石成金', desc: '隨機將一個格子變為 *2' }, // 舊 D1 改 E1
        
        { id: 'A2', lv: 2, w: 1, name: '優化運算', desc: '隨機將 2 個除法格變為乘法' },
        { id: 'B2', lv: 2, w: 2, name: '自動填補', desc: '每選擇 3 次，額外標記隨機一格' },
        { id: 'C2', lv: 2, w: 3, name: '戰意累積', desc: '每次連線後，永久增加 2 點基礎攻擊力' },
        { id: 'D2', lv: 2, w: 1, name: '時光沙漏 II', desc: '每回合起始剩餘次數 +5' }, // 新 D2
        { id: 'E2', lv: 2, w: 2, name: '數值暴漲', desc: '隨機將一個格子變為 +10' }, // 舊 D2 改 E2

        { id: 'A3', lv: 3, w: 1, name: '神聖倍率', desc: '隨機將一個格子變為 *10' },
        { id: 'B3', lv: 3, w: 1, name: '極速連線', desc: '只需 5 格即可達成連線' },
        { id: 'C3', lv: 3, w: 2, name: '極限突破', desc: '基礎攻擊力變為 (ATK/2)^2' },
        { id: 'D3', lv: 3, w: 1, name: '時光回溯', desc: '連線時補充 3 次行動' }, // 新 D3
        { id: 'E3', lv: 3, w: 3, name: '維度提升', desc: '隨機將一個格子變為 ^2 (平方)' } // 舊 D3 改 E3
    ];

    function showUpgradeUI() {
        const overlay = document.getElementById('upgrade-overlay');
        const container = document.getElementById('cards-container');
        container.innerHTML = '';
        overlay.style.display = 'flex';

        let choices = [];
        for(let i=0; i<3; i++) {
            let totalW = upgradeDefs.reduce((a,b)=>a+b.w, 0);
            let r = Math.random() * totalW;
            let sum = 0;
            for(let u of upgradeDefs) {
                sum += u.w;
                if(r <= sum) { choices.push(u); break; }
            }
        }

        choices.forEach(u => {
            const card = document.createElement('div');
            card.className = 'card';
            card.style.borderColor = u.lv === 3 ? '#d3adf7' : (u.lv === 2 ? '#ffec3d' : '#fff');
            card.innerHTML = `
                <div style="font-size:12px; color:${u.lv===3?'#d3adf7':'#fff'}">LV.${u.lv}</div>
                <div class="card-name">${u.name}</div>
                <div class="card-desc">${u.desc}</div>
            `;
            card.onclick = () => applyUpgradeLogic(u);
            container.appendChild(card);
        });
    }

    async function applyUpgradeLogic(u) {
        document.getElementById('upgrade-overlay').style.display = 'none';
        upgrades.push(u);
        addHistory(u);

        // 收集需要改變的格子 indices
        let changedIndices = [];
        // 暫存修改函式
        let modifyAction = () => {};

        if (u.id === 'A1') {
            modifyAction = () => {
                // A1 是特殊情況，indices 隨機選，選完後要確保動畫播在這些格子上
            };
            // 由於 A1 邏輯是重隨機，我們先選定 5 個位置
            for(let i=0; i<5; i++) changedIndices.push(rn(36));
            modifyAction = () => {
                changedIndices.forEach(idx => {
                    gridData[idx] = {op: ['+','-','*','/'][rn(4)], val: rn(4)+2, class:''};
                    gridData[idx].class = opConfig[gridData[idx].op].class;
                });
            };
        } 
        else if (u.id === 'A2') {
            let divs = gridData.map((d,i)=>d.op==='/'?i:-1).filter(i=>i!==-1);
            for(let i=0; i<2 && divs.length>0; i++) {
                changedIndices.push(divs.splice(rn(divs.length), 1)[0]);
            }
            modifyAction = () => {
                changedIndices.forEach(idx => gridData[idx] = {op:'*', val:2, class:'op-mult'});
            };
        } 
        else if (u.id === 'A3') {
            let idx = rn(36); changedIndices.push(idx);
            modifyAction = () => gridData[idx] = {op:'*', val:10, class:'op-mult'};
        }
        else if (u.id === 'E1') {
            let idx = rn(36); changedIndices.push(idx);
            modifyAction = () => gridData[idx] = {op:'*', val:2, class:'op-mult'};
        }
        else if (u.id === 'E2') {
            let idx = rn(36); changedIndices.push(idx);
            modifyAction = () => gridData[idx] = {op:'+', val:10, class:'op-plus'};
        }
        else if (u.id === 'E3') {
            let idx = rn(36); changedIndices.push(idx);
            modifyAction = () => gridData[idx] = {op:'^', val:2, class:'op-pow'};
        }
        else if (u.id === 'C1') baseAtk += 3;
        else if (u.id === 'C3') baseAtk = Math.pow(baseAtk/2, 2);

        // 執行棋盤動畫 (需求 3)
        if (changedIndices.length > 0) {
            // 1. 發亮到純白
            changedIndices.forEach(i => {
                const c = document.getElementById(`cell-${i}`);
                if(c) c.classList.add('flash-white');
            });
            await new Promise(r => setTimeout(r, 500));

            // 2. 替換數字 (此時被白色遮住)
            modifyAction();
            // 強制更新 DOM 文字但保持 class
            changedIndices.forEach(i => {
                const c = document.getElementById(`cell-${i}`);
                const d = gridData[i];
                if(c) {
                    c.innerText = `${d.op}${d.val}`;
                    c.className = `cell ${d.class} flash-white`; // 確保更新顏色class同時保持flash-white
                }
            });
            await new Promise(r => setTimeout(r, 500));

            // 3. 白色淡去
            changedIndices.forEach(i => {
                const c = document.getElementById(`cell-${i}`);
                if(c) c.classList.remove('flash-white');
            });
            await new Promise(r => setTimeout(r, 500));
        } else {
            // 沒有格子變動的升級 (如攻擊力)
            modifyAction();
        }

        nextStageLogic();
    }

    function nextStageLogic() {
        currentLevel++;
        enemyMaxHp += 50;
        if (currentLevel % 3 === 0) enemyMaxHp *= 2;
        enemyHp = enemyMaxHp;
        
        // 需求 5: 每一關開始時剩餘次數固定為 30 + D類升級
        let startTurns = 30;
        upgrades.forEach(u => {
            if (u.id === 'D1') startTurns += 3;
            if (u.id === 'D2') startTurns += 5;
        });
        remainingTurns = startTurns;
        
        markedData = Array(36).fill(false);
        pickNewOptions();
        updateUI();
    }

    function hasUpgrade(id) { return upgrades.some(u => u.id === id); }
    
    function addHistory(u) {
        const list = document.getElementById('upgrade-history');
        const div = document.createElement('div');
        div.className = 'history-item';
        div.innerHTML = `
            <div class="h-top"><span>${u.name}</span><span>LV.${u.lv}</span></div>
            <div class="h-desc">${u.desc}</div>
        `;
        list.appendChild(div);
    }

    // 不自動開始，等待點擊畫面
    // initGame(); 

</script>
</body>
</html>